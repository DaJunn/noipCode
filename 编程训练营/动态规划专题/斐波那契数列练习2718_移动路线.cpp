/*
	Name: 2718_移动路线
	Author: 巧若拙 
	Description: 
桌子上有一个m行n列的方格矩阵，将每个方格用坐标表示，行坐标从下到上依次递增，列坐标从左至右依次递增，左下角方格的坐标为(1,1)，则右上角方格的坐标为(m,n)。
小明是个调皮的孩子，一天他捉来一只蚂蚁，不小心把蚂蚁的右脚弄伤了，于是蚂蚁只能向上或向右移动。小明把这只蚂蚁放在左下角的方格中，蚂蚁从
左下角的方格中移动到右上角的方格中，每步移动一个方格。蚂蚁始终在方格矩阵内移动，请计算出不同的移动路线的数目。
对于1行1列的方格矩阵，蚂蚁原地移动，移动路线数为1；
对于1行2列（或2行1列）的方格矩阵，蚂蚁只需一次向右（或向上）移动，移动路线数也为1……对于一个2行3列的方格矩阵，如下图所示：

-------------------
|(2,1)|(2,2)|(2,3)|
-------------------
|(1,1)|(1,2)|(1,3)|
-------------------

蚂蚁共有3种移动路线：
路线1：(1,1) → (1,2) → (1,3) → (2,3)
路线2：(1,1) → (1,2) → (2,2) → (2,3)
路线3：(1,1) → (2,1) → (2,2) → (2,3)
输入
输入只有一行，包括两个整数m和n（0<m+n<=20），代表方格矩阵的行数和列数，m、n之间用空格隔开
输出
输出只有一行，为不同的移动路线的数目。
样例输入
2 3
样例输出
3

算法分析：简单递推，类似数塔问题，求总方案数量 
*/
#include<iostream> 
  
using namespace std;  
  
const int MAX = 100;   
int F[MAX+1][MAX+1]; 
int pre[MAX+1], cur[MAX+1]; 
int B[MAX+1];
  
int DP(int m, int n);//动态规划：二维数组  
int DP_2(int m, int n);//动态规划：2个一维数组 
int DP_3(int m, int n);//动态规划：1个一维数组 
  
int main()   
{  
    int m, n;  
    cin >> m >> n; 
    
    cout << DP(m, n) << endl;//动态规划：二维数组 
    cout << DP_2(m, n) << endl;//动态规划：2个一维数组 
    cout << DP_3(m, n) << endl;//动态规划：1个一维数组 
      
    return 0;  
}  

int DP(int m, int n) //动态规划：二维数组 
{ //利用下标为0的元素默认初始化为0，可以无需特别处理第一行和第一列   
    F[0][1] = 1; //为了获得F[1][1]的值，必须作此处理 	
    for (int i=1; i<=m; i++)
	{
		for (int j=1; j<=n; j++)
		{
			F[i][j] = F[i-1][j] + F[i][j-1];
		}
	}
	
	return F[m][n];
}   

int DP_2(int m, int n) //动态规划：2个一维数组
{ 
	for (int i=1; i<=n; i++) //设置第一行 
		pre[i] = 1;
		
    for (int i=2; i<=m; i++)
	{
		for (int j=1; j<=n; j++) //设置第i行 
			cur[j] = pre[j] + cur[j-1]; 
		for (int j=1; j<=n; j++) //复制第i行 
			pre[j] = cur[j]; 
	}
	
	return pre[n];
}   

int DP_3(int m, int n) //动态规划：1个一维数组
{ 
	for (int i=1; i<=n; i++) //设置第一行 
		B[i] = 1;
		
    for (int i=2; i<=m; i++)
	{
		for (int j=1; j<=n; j++) //设置第i行 
			B[j] += B[j-1]; 
	}
	
	return B[n];
}   
