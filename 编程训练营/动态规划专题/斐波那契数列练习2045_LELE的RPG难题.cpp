/*
	Name: 2045_LELE的RPG难题
	Copyright: 
	Author: 
	Date: 15-06-18 13:58
	Description: Problem Description
人称“AC女之杀手”的超级偶像LELE最近忽然玩起了深沉，这可急坏了众多“Cole”（LELE的粉丝,即"可乐"）,
经过多方打探，某资深Cole终于知道了原因，原来，LELE最近研究起了著名的RPG难题:
有排成一行的ｎ个方格，用红(Red)、粉(Pink)、绿(Green)三色涂每个格子，每格涂一色，
要求任何相邻的方格不能同色，且首尾两格也不同色．求全部的满足要求的涂法.
以上就是著名的RPG难题.
如果你是Cole,我想你一定会想尽办法帮助LELE解决这个问题的;如果不是,看在众多漂亮的痛不欲生的Cole女的面子上,你也不会袖手旁观吧?
Input
输入数据包含多个测试实例,每个测试实例占一行,由一个整数N组成，(0<n<=50)。
Output
对于每个测试实例，请输出全部的满足要求的涂法，每个实例的输出占一行。
Sample Input
1
2
Sample Output
3
6

算法分析：
题目要求是“相邻的方格不能同色，且首尾两格也不同色”，我们可以从左到右一个一个格子涂色，先要确保已经涂色的格子能满足条件，
再涂后面的格子。我们用F[n]表示n个连续方格组成的正确序列的数量，则F[1]=3,F[2]=6,F[3]=6;
在涂第n个格子的时候，第n-1个格子可以有两种情况，一是第n-1个格子与第1个格子不同色，这样第n个格子只有1种选择，
因为此时前n-1个格子本身是一个正确序列，则 F[n]=F[n-1]； 
二是第n-1个格子与第1个格子同色，这样第n个格子有2种选择，此时前n-1个格子非正确序列，但前n-2个格子是正确序列，则 F[n]=2F[n-2]；
故 F[n]=F[n-1] + 2F[n-2] (n > 2)
网友提供：该提解题思路为：找规律 可通过公式：F[n]=F[n-1]+2*F[n-2]来解答	下面是公式的递推：
n个方格可以由n-1个方格和n-2个方格填充得到。
比如，在一涂好的n-1个格子里最后再插入一个格子，就得到了n个格子了。
因为已经填好n-1的格子中，每两个格子的颜色都不相同。
所以只能插入一种颜色。而n-1个格子一共有F[n-1]种填涂方法。所以从n-1格扩充到n格共有F(n-1)种方法。
若前n-1不合法，而添加一个后变成合法，即前n-2个合法，而第n-1个与第1个相同。
这时候有两种填法。
可以理解为若a[n-1]与a[0]颜色不同，则添加的一个格子只有一种填法，若a[n-1]与a[0]相同，则a[n-2]与a[0]不同，
则最后有两种填法可得递归公式为：F[n]=F[n-1]+F[n-2]*2 
*/
#include<iostream>  
#include<cmath>  
  
using namespace std;  
  
const int MAXN = 51;  
long long F1[MAXN];//RPG数列 
long long F2[MAXN] = {0, 3, 6, 6};//PRG数列  
  
long long PRG_1(int n); //备忘录：自顶而下  
long long PRG_2(int n);//动态规划：自底而上  
  
int main()   
{  
    int n;  
	
	PRG_2(MAXN); //动态规划，先记录所有子问题的解 

	while (cin >> n)  
    {  
       // cout << PRG_1(n) << endl;
        cout << F2[n] << endl;
    }  
      
    return 0;  
}  

long long PRG_1(int n) //备忘录：自顶而下  
{  
    if (F1[n] > 0)  //如果这个问题曾经计算过，直接返回   
    {  
        return F1[n];  
    }
    if (n == 1)  //递归出口 
    {  
        F1[n] = 3;  
    }   
	else if (n == 2 || n == 3)  //递归出口 
    {  
        F1[n] = 6;  
    }   
    else
    {
		F1[n] = PRG_1(n-1) + 2 * PRG_1(n-2);  
	}
    
    return F1[n];
}  
  
long long PRG_2(int n)//动态规划：自底而上  
{  
    for (int i=4; i<=n; i++)  
    {  
        F2[i] = F2[i-1] + 2 * F2[i-2];  
    }  
      
    return F2[n];  
}  
