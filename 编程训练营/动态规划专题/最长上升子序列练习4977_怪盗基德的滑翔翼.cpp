/*
	Name: 4977_怪盗基德的滑翔翼
	Author: 巧若拙 
	Description: 4977_怪盗基德的滑翔翼
描述
怪盗基德是一个充满传奇色彩的怪盗，专门以珠宝为目标的超级盗窃犯。而他最为突出的地方，就是他每次都能逃脱中村警部的重重围堵，
而这也很大程度上是多亏了他随身携带的便于操作的滑翔翼。
有一天，怪盗基德像往常一样偷走了一颗珍贵的钻石，不料却被柯南小朋友识破了伪装，而他的滑翔翼的动力装置也被柯南踢出的足球破坏了。
不得已，怪盗基德只能操作受损的滑翔翼逃脱。
假设城市中一共有N幢建筑排成一条线，每幢建筑的高度各不相同。初始时，怪盗基德可以在任何一幢建筑的顶端。
他可以选择一个方向逃跑，但是不能中途改变方向（因为中森警部会在后面追击）。
因为滑翔翼动力装置受损，他只能往下滑行（即：只能从较高的建筑滑翔到较低的建筑）。
他希望尽可能多地经过不同建筑的顶部，这样可以减缓下降时的冲击力，减少受伤的可能性。
请问，他最多可以经过多少幢不同建筑的顶部（包含初始时的建筑）？

输入
输入数据第一行是一个整数K（K < 100），代表有K组测试数据。
每组测试数据包含两行：第一行是一个整数N(N < 100)，代表有N幢建筑。
第二行包含N个不同的整数，每一个对应一幢建筑的高度h（0 < h < 10000），按照建筑的排列顺序给出。
输出
对于每一组测试数据，输出一行，包含一个整数，代表怪盗基德最多可以经过的建筑数量。
样例输入
3
8
300 207 155 299 298 170 158 65
8
65 158 170 298 299 155 207 300
10
2 1 3 4 5 6 7 8 9 10
样例输出
6
6
9
*/
#include<iostream>
#include<cstring>

using namespace std;

const int MAX = 101; 
int A[MAX];
int S2[MAX]; //记录到元素i为止的最长上升子序列的长度 
int S3[MAX+1]; //记录最长上升子序列，下标从1开始 

int DP_2(int n); //顺序处理 
int DP_3(int n); //顺序处理，二分插入 
int Pos(int low, int high, int x);//二分查找，返回第一个比x大的元素下标 

int main() 
{
	int t, n;
	cin >> t;
	for (int k=0; k<t; k++)
	{
		cin >> n;
		for (int i=0; i<n; i++)
		{
			cin >> A[i];
		}
		memset(S2, 0, sizeof(S2));
		cout << DP_2(n) << endl;//顺序处理，需要用到全局变量A[MAX]，另有S2[MAX]初始化为0。
		
		memset(S3, 0, sizeof(S3));
		cout << DP_3(n) << endl;//顺序处理，需要用到全局变量A[MAX]，另有S3[MAX]初始化为0。
	}
	
    return 0;
}

int DP_2(int n) //顺序搜索 
{
	int maxLen = 0; //记录最长上升子序列的长度 
	
	for (int i=0; i<n; i++)
	{ 
		for (int j=i-1; j>=0; j--)//逆序查找不大于A[i]，且最长的元素，找到后更新S[i]的值
		{
			if (A[i] > A[j] && S2[j] > S2[i])
				S2[i] = S2[j];
		}
		S2[i]++; //因为S[i]初始化为0，故长度应增1 
		if (maxLen < S2[i]) 
			maxLen = S2[i];
	}
	
	if (maxLen < n / 2)//长度不到一半，再看递减能否取得更大值 
	{
		memset(S2, 0, sizeof(S2));
		for (int i=0; i<n; i++)
		{ 
			for (int j=i-1; j>=0; j--)//逆序查找不小于A[i]，且最长的元素，找到后更新S[i]的值
			{
				if (A[i] < A[j] && S2[j] > S2[i])
					S2[i] = S2[j];
			}
			S2[i]++; //因为S[i]初始化为0，故长度应增1 
			if (maxLen < S2[i]) 
				maxLen = S2[i];
		}
	} 
	
	return maxLen;
}

int DP_3(int n) //顺序搜索，二分插入 
{
	int m1 = 0, m2 = 0; //记录最长不下降子序列的长度 
	
	S3[++m1] = A[0]; //S3下标从1开始 
	for (int i=1; i<n; i++)
	{
		if (A[i] > S3[m1])//直接接在后面并使子序列长度增1 
		{
			S3[++m1] = A[i];
		}
		else //二分查找，并插入到适当位置（第一个比A[i]大的元素） 
		{
			S3[Pos(1, m1-1, A[i])] = A[i];
		}
	}
	
	if (m1 < n / 2)//长度不到一半，再看递减能否取得更大值
	{
		S3[++m2] = A[n-1]; //S3下标从1开始 
		for (int i=n-2; i>=0; i--)
		{
			if (A[i] > S3[m2])//直接接在后面并使子序列长度增1 
			{
				S3[++m2] = A[i];
			}
			else //二分查找，并插入到适当位置（第一个比A[i]大的元素） 
			{
				S3[Pos(1, m2-1, A[i])] = A[i];
			}
		}
	}
	
	return max(m1, m2);
}

int Pos(int low, int high, int x)//二分查找，返回第一个比x大的元素下标 
{
	int mid;
	
	while (low <= high)
	{
		mid = (low + high)/2;
		if (S3[mid] > x)
		{
			high = mid - 1;
		}
		else
		{
			low = mid + 1;
		}
	}
	
	return low;//此时S3[low] > x
}
