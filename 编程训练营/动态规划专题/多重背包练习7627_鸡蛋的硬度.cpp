/*
	Name: 7627_鸡蛋的硬度
	Copyright: 
	Author: 
	Date: 26-06-18 21:40
	Description: 7627_鸡蛋的硬度
查看 提交 统计 提问
总时间限制: 1000ms 内存限制: 65536kB
描述
最近XX公司举办了一个奇怪的比赛：鸡蛋硬度之王争霸赛。参赛者是来自世 界各地的母鸡，比赛的内容是看谁下的蛋最硬，更奇怪的是XX公司并不使用什么精密仪器来测量蛋的硬度，他们采用了一种最老土的办法--从高度扔鸡蛋--来 测试鸡蛋的硬度，如果一次母鸡下的蛋从高楼的第a层摔下来没摔破，但是从a+1层摔下来时摔破了，那么就说这只母鸡的鸡蛋的硬度是a。你当然可以找出各种 理由说明这种方法不科学，比如同一只母鸡下的蛋硬度可能不一样等等，但是这不影响XX公司的争霸赛，因为他们只是为了吸引大家的眼球，一个个鸡蛋从100 层的高楼上掉下来的时候，这情景还是能吸引很多人驻足观看的，当然，XX公司也绝不会忘记在高楼上挂一条幅，写上“XX公司”的字样--这比赛不过是XX 公司的一个另类广告而已。 
勤于思考的小A总是能从一件事情中发现一个数学问题，这件事也不例外。“假如有很多同样硬度的鸡蛋，那么我可以用二分的办法用最少的次数测出鸡蛋 的硬度”，小A对自己的这个结论感到很满意，不过很快麻烦来了，“但是，假如我的鸡蛋不够用呢，比如我只有1个鸡蛋，那么我就不得不从第1层楼开始一层一 层的扔，最坏情况下我要扔100次。如果有2个鸡蛋，那么就从2层楼开始的地方扔……等等，不对，好像应该从1/3的地方开始扔才对，嗯，好像也不一定 啊……3个鸡蛋怎么办，4个，5个，更多呢……”，和往常一样，小A又陷入了一个思维僵局，与其说他是勤于思考，不如说他是喜欢自找麻烦。 
好吧，既然麻烦来了，就得有人去解决，小A的麻烦就靠你来解决了：）

输入
输入包括多组数据，每组数据一行，包含两个正整数n和m(1<=n<=100,1<=m<=10)，其中n表示楼的高度，m表示你现在拥有的鸡蛋个数，这些鸡蛋硬度相同（即它们从同样高的地方掉下来要么都摔碎要么都不碎），并且小于等于n。你可以假定硬度为x的鸡蛋从高度小于等于x的地方摔无论如何都不会碎（没摔碎的鸡蛋可以继续使用），而只要从比x高的地方扔必然会碎。
对每组输入数据，你可以假定鸡蛋的硬度在0至n之间，即在n+1层扔鸡蛋一定会碎。
输出
对于每一组输入，输出一个整数，表示使用最优策略在最坏情况下所需要的扔鸡蛋次数。
样例输入
100 1
100 2
样例输出
100
14
提示
最优策略指在最坏情况下所需要的扔鸡蛋次数最少的策略。
如果只有一个鸡蛋，你只能从第一层开始扔，在最坏的情况下，鸡蛋的硬度是100，所以需要扔100次。如果采用其他策略，你可能无法测出鸡蛋的硬度(比如你第一次在第二层的地方扔,结果碎了,这时你不能确定硬度是0还是1)，即在最坏情况下你需要扔无限次，所以第一组数据的答案是100。
算法思想：
我们用B1[i][j]给定i个鸡蛋测试j层楼时的最优解，可以穷举从第k层楼(1<=k<=j)扔下一个鸡蛋，判断鸡蛋是否破碎，
比较鸡蛋碎和不碎两种情况下的解，取较大值(即最坏情况)再加1。最后再取各种情况中的最小值作为最优解。 
*/
#include<iostream>  
#include<cstring>  
  
using namespace std;  
 
const int INF = 5000; //自定义的最大值    
const int MAXH = 100; //楼的高度 
const int MAXM = 10; //鸡蛋个数     
int B1[MAXM+1][MAXH+1]; //记录给定i个鸡蛋和j层楼的最优解。 
int B2[MAXM+1][MAXH+1]; //记录给定i个鸡蛋和j层楼的最优解。
  
int Best_1(int n, int m);//动态规划:二维数组存储结果  
int MDFS(int i, int j);//备忘录算法 
  
int main()   
{  
    int n, m;  
      
    while (cin >> n >> m)
    {  
		for (int i=1; i<=m; i++)
		{
			for (int j=1; j<=n; j++)
			{
				B1[i][j] = j;
				B2[i][j] = INF;
			}
		}
      //  cout << Best_1(m, n) << endl;  
        cout << MDFS(m, n) << endl;  
    }  
    
    return 0;  
}  
  
int Best_1(int m, int n)//动态规划:二维数组存储结果  
{  
    for (int i=2; i<=m; i++) //给定前i个鸡蛋   
    {  
        for (int j=1; j<=n; j++) //给定j层楼 
        {//朴素的穷举思想，计算给定i个鸡蛋测试j层楼时的最优解   
            int bestP = j;//初始化为最大值   
            for (int k=1; k<=j; k++) //用一个鸡蛋从第k层楼扔下来，看看是否会破碎 
            { //B1[i-1][k-1]表示第i个鸡蛋在第k层摔碎了，则用剩下的i-1个鸡蛋来测试前k-1层楼 
              //B1[i][j-k] 表示第i个鸡蛋在第k层没摔碎，则还剩i个鸡蛋继续测试剩下的j-k层楼 
                if (bestP > max(B1[i-1][k-1], B1[i][j-k]) + 1) //两种情况中选择较大值，再加上测试第k层楼的那一次 
                    bestP = max(B1[i-1][k-1], B1[i][j-k]) + 1;  
            }  
            B1[i][j] = bestP;  
        }  
    }  
      
    return B1[m][n];  
}  

int MDFS(int i, int j)//备忘录算法   
{  
    if (B2[i][j] != INF)  
        return B2[i][j];  
    if (i==1 || j==1) //只有1个鸡蛋或只有1层楼 
        return j;  
    int bestP = INF;  
    for (int k=1; k<=j; k++)  
    {  
        if (bestP > max(MDFS(i-1, k-1), MDFS(i, j-k)) + 1) //两种情况中选择较大值，再加上测试第k层楼的那一次 
            bestP = max(MDFS(i-1, k-1), MDFS(i, j-k)) + 1;  
    }  
      
    return B2[i][j] = bestP;   
}  
  
