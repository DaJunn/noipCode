/*
	Name: 1700_八皇后问题
	Copyright: 
	Author: 
	Date: 13-07-17 19:34
	Description: 1700_八皇后问题
查看 提交 统计 提问
总时间限制: 10000ms 内存限制: 65536kB
描述
在国际象棋棋盘上放置八个皇后，要求每两个皇后之间不能直接吃掉对方。
输入
无输入。
输出
按给定顺序和格式输出所有八皇后问题的解（见Sample Output）。
样例输入
样例输出
No. 1
1 0 0 0 0 0 0 0 
0 0 0 0 0 0 1 0 
0 0 0 0 1 0 0 0 
0 0 0 0 0 0 0 1 
0 1 0 0 0 0 0 0 
0 0 0 1 0 0 0 0 
0 0 0 0 0 1 0 0 
0 0 1 0 0 0 0 0 
No. 2
1 0 0 0 0 0 0 0 
0 0 0 0 0 0 1 0 
0 0 0 1 0 0 0 0 
0 0 0 0 0 1 0 0 
0 0 0 0 0 0 0 1 
0 1 0 0 0 0 0 0 
0 0 0 0 1 0 0 0 
0 0 1 0 0 0 0 0 
No. 3
1 0 0 0 0 0 0 0 
0 0 0 0 0 1 0 0 
0 0 0 0 0 0 0 1 
0 0 1 0 0 0 0 0 
0 0 0 0 0 0 1 0 
0 0 0 1 0 0 0 0 
0 1 0 0 0 0 0 0 
0 0 0 0 1 0 0 0 
No. 4
1 0 0 0 0 0 0 0 
0 0 0 0 1 0 0 0 
0 0 0 0 0 0 0 1 
0 0 0 0 0 1 0 0 
0 0 1 0 0 0 0 0 
0 0 0 0 0 0 1 0 
0 1 0 0 0 0 0 0 
0 0 0 1 0 0 0 0 
No. 5
0 0 0 0 0 1 0 0 
1 0 0 0 0 0 0 0 
0 0 0 0 1 0 0 0 
0 1 0 0 0 0 0 0 
0 0 0 0 0 0 0 1 
0 0 1 0 0 0 0 0 
0 0 0 0 0 0 1 0 
0 0 0 1 0 0 0 0 
No. 6
0 0 0 1 0 0 0 0 
1 0 0 0 0 0 0 0 
0 0 0 0 1 0 0 0 
0 0 0 0 0 0 0 1 
0 1 0 0 0 0 0 0 
0 0 0 0 0 0 1 0 
0 0 1 0 0 0 0 0 
0 0 0 0 0 1 0 0 
No. 7
0 0 0 0 1 0 0 0 
1 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 1 
0 0 0 1 0 0 0 0 
0 1 0 0 0 0 0 0 
0 0 0 0 0 0 1 0 
0 0 1 0 0 0 0 0 
0 0 0 0 0 1 0 0 
No. 8
0 0 1 0 0 0 0 0 
1 0 0 0 0 0 0 0 
0 0 0 0 0 0 1 0 
0 0 0 0 1 0 0 0 
0 0 0 0 0 0 0 1 
0 1 0 0 0 0 0 0 
0 0 0 1 0 0 0 0 
0 0 0 0 0 1 0 0 
No. 9
0 0 0 0 1 0 0 0 
1 0 0 0 0 0 0 0 
0 0 0 1 0 0 0 0 
0 0 0 0 0 1 0 0 
0 0 0 0 0 0 0 1 
0 1 0 0 0 0 0 0 
0 0 0 0 0 0 1 0 
0 0 1 0 0 0 0 0 
...以下省略
提示
此题可使用函数递归调用的方法求解。

注意：从样例来看，输出要按列优先处理！！！ 
因为是列序优先，控制台又只能一行行向下输出，故必须存储整个矩阵，以便输出
*/
#include<iostream>
#include<cmath>

using namespace std;

const int N = 8; //皇后的个数
int row[N];//记录n个皇后的行坐标 
bool b[N]; //b[j]==0表示行j可用
bool c[N+N]; //c[j]==0表示左上-右下斜线可用, i - row[i] == j - row[j]
bool d[N+N]; //d[j]==0表示右上-左下斜线可用  i + row[i] == j + row[j]
int sum = 0;//保存可以放置的方案数

void Backtrace(int r); //递归回溯，r表示第r列 
void Backtrace_2(int r);

int main() 
{
   Backtrace(0);
   
   for (int i=1; i<=92; i++)
   
   return 0;
}

void Backtrace(int r) //递归回溯，r表示第r列 
{
    if(r == N)
    { 
		int map[N][N] = {0}; //存储输出表格（列序优先） 
		for(int i=0; i<N; i++)//因为是列序优先，控制台又只能一行行向下输出，故必须存储整个矩阵，以便输出 
		{
			map[row[i]][i] = 1;
		}
        cout << "No. " << ++sum << endl;
        for(int i=0; i<N; i++)
        {
			for (int j=0; j<N; j++)
			{
				cout << map[i][j] << " ";
			}
			cout << endl;
        }
    }
    else
    {
        for(int j=0; j<N; j++)//可能的行号 
        {
			if((!b[j])&& (!c[r-j+N]) && (!d[r+j])) //c[i-j+N]是为了确保下标不越界 
			{
				row[r] = j;
				b[j] = 1;   //宣布占领行j 
				c[r-j+N] = 1; //宣布占领两条斜线 
				d[r+j] = 1;
				Backtrace(r+1); //继续递归放置下一个皇后 
				//还原，以便回溯 
				b[j] = 0;  
				c[r-j+N] = 0; 
				d[r+j] = 0;
			}
        }
    }
}
