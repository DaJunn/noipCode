/*
	Name: 纸牌游戏之插入牌堆 
	Copyright: 
	Author: 
	Date: 06\09\18 10:39
	Description: 小明设计了一种纸牌游戏，每张纸牌上都有一个100以内的数字，每个数字对应的纸牌只有一张。
	初始时所有的纸牌从上到下按数字大小顺序叠成一堆，如果从中抽走一张，小明就按抽走的纸牌位置分为两堆。
	对每堆纸牌，小明采用记忆最顶端牌的数字和这堆牌的张数记录。
	如剩余的牌为1,2,3,5,6,11，则牌分为3堆，记录为(1,3),(5,2),(11,1)。
	现在有些牌采用如下规则要放回牌堆，有4种情况：
	1.上靠，例如放回的牌数字为7，则放至第二堆牌的最下方，原记录变成(1,3),(5,3),(11,1)。
	2.下靠，例如放回的牌数字为10，则放至第三堆牌的最上方，原记录变成(1,3),(5,2),(10,2)。
	3.上下靠，例如放回的牌数字为4，则合并第1堆和第2堆，原记录变成(1,6),(10,2)。
	3.上下不靠，例如放回的牌数字为9，则新增一堆，原记录变成(1,3),(5,2),(9,1),(11,1)。
	给定已有记录（分别用数组元素a[i]和b[i]存储第i堆牌的顶端牌数字和张数），
	根据上述描述，输出插入数字为num(num > 1)的纸牌后的新记录，并返回新纪录的数量（牌堆的数量）。 
*/
#include<iostream>
#include<ctime>
#include<cstdio>
#include<cstdlib>

using namespace std;

const int M = 20;

int Fun(int a[], int b[], int n, int key);//保证插入的纸牌数字大于1 

int main() 
{
	int a[M] = {1}, b[M]={rand()%10+1};
	int n  = 3;
	for (int i=1; i<n; i++)
	{
		a[i] = rand() % 10 + a[i-1] + b[i-1] + 1;
		b[i] = rand() % 10 + 1;
	}
		
	for (int i=0; i<n; i++)
	{
		cout << "(" << a[i] << "," << b[i] << ") ";
	}
	cout << endl;
	
	n = Fun(a, b, n, 16);//保证插入的纸牌数字大于1 
	
	for (int i=0; i<n; i++)
	{
		cout << "(" << a[i] << "," << b[i] << ") ";
	}
	cout << endl;

	
	return 0;	
} 

int Fun(int a[], int b[], int n, int key)//保证插入的纸牌数字大于1 
{
	int i = 0;
	while (a[i] > 0 && a[i] < key) //查找牌key放的位置，i指向下一堆牌 
		i++;
	
	i -= 1; //i指向上一堆牌 
	if (a[i]+b[i] == key) //上靠
	{
		if (a[i+1] == key+1)//上下靠
		{
			b[i] += 1 + b[i+1];
			for (int j=i+1; j<n-1; j++)//合并堆
			{
				a[j] = a[j+1];
				b[j] = b[j+1];
		 	} 
		 	n--;
		} 
		else //仅上靠
		{
			b[i] += 1;
	 	} 
	} 
	else if (a[i+1] == key+1)//仅下靠
	{
		a[i+1] = key;
		b[i+1] += 1;
	} 
	else //上下不靠 
	{
		for (int j=n; j>i+1; j--)//腾出位置，添加新堆 
		{
		    a[j] = a[j-1];
			b[j] = b[j-1];
	 	} 
	 	a[i+1] = key;
	 	b[i+1] = 1;
	 	n++;
	}
	
	return n;
}




