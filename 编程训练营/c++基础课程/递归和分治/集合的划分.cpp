/*
	Name: 
	Copyright: 
	Author: 
	Date: 15-01-18 14:25
	Description: 
【问题描述】 
设S是一个具有n个元素的集合，S＝｛a1，a2，……，an｝，现将S划分成k个满足下列条件的子集合S1，S2，……，Sk ，且满足：这里写图片描述 则称S1，S2，……，Sk是集合S的一个划分。它相当于把S集合中的n个元素a1 ，a2，……，an 放入k个（0＜k≤n＜30＝无标号的盒子中，使得没有一个盒子为空。请你确定n个元素a1 ，a2 ，……，an 放入k个无标号盒子中去的划分数S(n，k)。 
【输入样例】setsub.in 
23 7 
【输出样例】setsub.out 
4382641999117305 
【算法分析】 
先举个例子，设S＝｛1，2，3，4｝，k＝3，不难得出S有6种不同的划分方案，即划分数S(4，3)=6，具体方案为： 
｛1，2｝∪｛3｝∪｛4｝ ｛1，3｝∪｛2｝∪｛4｝ ｛1，4｝∪｛2｝∪｛3｝ 
｛2，3｝∪｛1｝∪｛4｝ ｛2，4｝∪｛1｝∪｛3｝ ｛3，4｝∪｛1｝∪｛2｝ 
考虑一般情况，对于任意的含有n个元素a1 ，a2，……，an的集合S，放入k个无标号的盒子中去，划分数为S(n，k)，我们很难凭直觉和经验计算划分数和枚举划分的所有方案，必须归纳出问题的本质。其实对于任一个元素an，则必然出现以下两种情况： 
1、｛an｝是k个子集中的一个，于是我们只要把a1，a2，……，an-1 划分为k－1子集，便解决了本题，这种情况下的划分数共有S(n－1，k－1)个； 
2、｛an｝不是k个子集中的一个，则an必与其它的元素构成一个子集。则问题相当于先把a1，a2，……，an-1 划分成k个子集，这种情况下划分数共有S(n－1，k)个；然后再把元素an加入到k个子集中的任一个中去，共有k种加入方式，这样对于an的每一种加入方式，都可以使集合划分为k个子集，因此根据乘法原理，划分数共有k * S(n－1，k)个。 
综合上述两种情况，应用加法原理，得出n个元素的集合｛a1，a2，……，an｝划分为k个子集的划分数为以下递归公式：S(n，k)＝S(n－1，k－1) + k * S(n－1，k) (n>k，k>0)。 
下面，我们来确定S(n，k)的边界条件,首先不能把n个元素不放进任何一个集合中去，即k=0时，S(n，k)＝0；
也不可能在不允许空盒的情况下把n个元素放进多于n的k个集合中去，即k＞n时,S(n，k)＝0；
再者，把n个元素放进一个集合或把n个元素放进n个集合，方案数显然都是1，即k=1或k=n时，S(n,k)=1。 
因此，我们可以得出划分数S(n，k)的递归关系式为： 
S(n，k)＝S(n－1，k－1) + k * S(n－1，k) (n>k，k>0) 
S(n，k)＝0 (n
*/
#include<iostream>
#include<cmath>
#include<ctime>

using namespace std;

const int N = 1000;
const int K = 1000;
int A[N+1][K+1];
int B[N+1][K+1];

int S(int n, int k)//递归 
{
	if (n < k || k == 0)
		return 0;
	if (n == k || k == 1)
		return 1;
	
	return S(n-1,k-1) + S(n-1,k)*k;
}

int S2(int n, int k) //记忆化搜索 
{
	if (A[n][k] != 0)
		return A[n][k];
	if (n < k || k == 0)
		A[n][k] = 0;
	else if (n == k || k == 1)
		A[n][k] = 1;
	else
		A[n][k] = S2(n-1,k-1) + S2(n-1,k)*k;
	return A[n][k];
}

void S3(int n) //动态规划 
{
	for (int i=1; i<=n; i++)
	{
		B[i][1] = B[i][i] = 1;
	}
	
	for (int i=2; i<=n; i++)
	{
		for (int j=2; j<i; j++)
		{
			B[i][j] = B[i-1][j-1] + B[i-1][j] * j;
		}
	}
}

int main() 
{
	S3(N);
	int n = 10, k = 7;
	
	for (n=1; n<=10; n++)
	{
		for (k=1; k<=10; k++)
		{   cout << n << " " << k << ": ";
			cout << S(n, k) << "  ";
		    cout << S2(n, k) << "  ";
		    cout << B[n][k] << endl;
		}
	}
    
    
 	
    return 0;
}



