/*
	Name: 22_神奇的幻方
	Copyright: 
	Author: 
	Date: 31-08-17 14:27
	Description: 22_神奇的幻方
查看 提交 统计 提问
总时间限制: 1000ms 内存限制: 65535kB
描述
幻方是一个很神奇的N*N矩阵，它的每行、每列与对角线，加起来的数字和都是相同的。
我们可以通过以下方法构建一个幻方。（阶数为奇数）
1.第一个数字写在第一行的中间
2.下一个数字，都写在上一个数字的右上方：
    a.如果该数字在第一行，则下一个数字写在最后一行，列数为该数字的右一列
    b.如果该数字在最后一列，则下一个数字写在第一列，行数为该数字的上一行
    c.如果该数字在右上角，或者该数字的右上方已有数字，则下一个数字写在该数字的下方

输入
一个数字N（N<=20）
输出
按上方法构造的2N-1 * 2N-1的幻方
样例输入
3
样例输出
17 24 1 8 15
23 5 7 14 16
4 6 13 20 22
10 12 19 21 3
11 18 25 2 9
*/
#include <iostream>

using namespace std;

const int M = 40;
const int N = 40;
int A[N][M];

int main() 
{
	int n, r, c, s=1;
	cin >> n;
	n = 2 * n - 1;
	r = 0;
	c = n / 2;
	A[r][c] = s++;
	while (s <= n*n)
	{
		if ((r == 0 && c == n-1) || (r>0 && c<n-1 && A[r-1][c+1] != 0))//右上角 
		{
			r = r + 1;
			A[r][c] = s++;
		}
		else if (r == 0 && c < n-1) //第一行且非最后列 
		{
			r = n -1;
			c = c + 1;
			A[r][c] = s++;
		}
		else if (c == n-1)//最后一列
		{
			r = r -1;
			c = 0;
			A[r][c] = s++;
		}
		else
		{
			r = r -1;
			c = c + 1;
			A[r][c] = s++;
		}
	}
	
	for (int i=0; i<n; i++)
	{
		for (int j=0; j<n; j++)
		{
			cout << A[i][j] << " ";
		}
		cout << endl;
	}
	
	return 0;	
} 

